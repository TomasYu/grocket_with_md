This file is encoding by UTF8 with signature.
Recommend use UltraEdit to see me. :-P

使用手册 - "caoxinyu"

【广告】Powered by GRocket. (2013-12-10)  
  1) 听说你一直在抱怨你牛逼的代码没有合适的框架能承载？来吧少年，本框架  
     每秒114万请求的TCP长连接处理速度能否释放你的代码? 
  2) 什么？你想设计与TCP、UDP无关的协议？把你牛逼的代码放过来吧！你  
     只管编写你的牛逼协议，框架帮你拿到TCP和UDP上去处理? 
  3) 你喜欢HTTP协议，但讨厌HTTP解析？你在问为什么HTTP只能运行在TCP?  
     本框架不但非常简单的支持HTTP长连接与短连接，还能直接在UDP上处? 
     HTTP协议，你要做的，只是把一?on_http 类似的函?糊弄'完? 
  4) 挑事儿的你在一旁冷冷的问：“我想在一个TCP连接中发一个自定义二进? 
     协议包，再发一个HTTP包，然后再发一个文本格式包....?别说了哥，我  
     看你是没事儿找抽型的！不过框架确实支持这个，虽然听着有点儿蛋疼? 
     没办法，架构设计的太好了，想不支持都不行? 
  5) 你说框架对你来说全是浮云？除了牛逼的核心业务代码以外，一行多余的  
     代码也不想写？试试全新的代码自动生成工具吧！下面的命令是生成框架  
     代码的例子：  
     grtool create_module -name HelloWorld -dir /tmp/hello_world -tcp_port 8000



框架自动生成代码的目录树介绍? 

conf        - 配置文件目录  
framework   - 服务器框架的一个预编译版本，绝对不允许修改? 
make        - makefile或工程文? 
make/vc2005 - Windows的VC2005工程文件  
make/linux  - Linux的makefile  
module      - "caoxinyu" 服务器源? 
interface   - "caoxinyu" 纯功能模块外部接口头文件  
src         - "caoxinyu" 纯功能模块实? 
unittest    - 单元测试  
include     - module,src,unittest 共用的内部接口头文件  

框架自动生成代码问答? 

1、问：为什么有 framework 目录？那里面有头文件也有二进制文?  
   答：framework 存放的是服务器框架的一个预编译版本，为了避免框架版? 
      更新带来的影响，在这里放框架的一个快照。里面有如下文件? 

      grocket.h    - 服务器框架接口文件? 
      libgrocket.h - 框架使用者如果想自己提供可执行文件来使用框架? 
                     则该头文件提供支持? 
      gr_stdinc.h  - grocket.h 依赖的一些平台相关的数据类型定义? 
      libgrocket.a - libgrocket.h 文件的功能实现。只有在框架使用  
                     者自己提供可执行文件来使用框架的情况下才需要使  
                     用该?这主要是为了满足一些特殊需?? 
      caoxinyu_svr.exe- 框架提供的可执行文件(这是大部分场景对  
                     框架的使用方?。只需要grocket.h就能给框架写  
                     服务器扩展模块，不需要连接任何库? 
                     你可能会注意到，可执行文件被改名了。是的，  
                     只要保证配置文件和可执行文件的主文件名是一致的  
                     可以随便改名，所以你可以看到module目录下的配置  
                     文件? caoxinyu_svr.ini  

2、问：make 目录是干什么的? 
   答：目前，make 目录下面有两个目录：vc和linux，顾名思议? 
      将来，可能会由于支持更多的平台或开发工具而增加更多的目录? 

3、问：interface 目录是干什么的? 
   答：我们的目录划分把功能分层了。我们这个项目的主题? caoxinyu? 
      这个主题的纯功能实现是可以独立的，所以我们把它抽离出来，创建? 
      interface 目录存放对外的接口头文件，?src 目录则专注把? 
      interface 目录中的头文件所定义的接口实现出来? 

4、问：module 目录是干什么的? 
   答：你可以把 module 目录看做是真正的服务器程序，实际上它是框架的  
      一个以动态链接库形式出现的插件。编译后，在Linux下输?libcaoxinyu_module.so.
      在启动框架服务器主程序时，它会从  caoxinyu_svr.ini配置  
      文件中找到[server]module=./caoxinyu_module 配置? 
      于是libcaoxinyu_module.so 就被加载了。配置文件里这么  
      写，很明显目的是跨平台。在Windows下module的编译输出是  caoxinyu_module.dll? 

5、问：src 目录是干什么的? 
   答：从目录名就能看得出来，src 目录里放的才是最关键的代码，既然模块  
      名称? caoxinyu，那当然这个目录里存放的是它的纯逻辑? 
      换句话说：module 模块自己完成协议分析工作，然后通过调用 src  
      完成业务逻辑。“蛋疼啊！?悟空你又在尖叫了，好吧，我能理解你，  
      但请听我说完。把纯业务逻辑抽离出来是基于这么几点考虑的：  
      1) 任何程序员在将其它框架应用到自己负责的模块上时，第一个要考虑  
         的问题是什么？隔离！对！就是隔离！在这种情况下没考虑到隔离的  
         程序员是不称职的。我们应该尽量降低业务代码和框架代码的耦合面? 
         这不但降低了业务代码与框架耦合带来的风险，同时对框架构成了一  
         种合理的压力（更换框架的成本不是那么大），便于激励双方发展? 
      2) 最大限度的发挥业务代码的通用性。与什么都不依赖的代码，可重用  
         性才最好。本框架除了以服务器扩展的方式写模块以外，还支持另外  
         一种写模块的方法，就是模块直接导出一个C风格的函数集，然后? 
         过动态描述文本将这个函数集导出成一个本地或远程调用接口，以RPC  
         类似的方法调用。如此拆分模块便于天生的产出这种类型的模块? 

6、问：include 目录是干什么的？它?interface 有什么区?  
   答：在前面讨?src 目录时我们谈到了框架还支持另外一种以RPC形式编写  
      模块的方法，interface 目录就用于存放这种RPC形式接口的C风格接口  
      函数的声明。这种接口一来可以直接用作其它用途，二来可以由框架直? 
      装载并提供RPC风格的动态调用? 
      ?include 目录则只用于服务器扩展模块的几个子模?module和src  
      目录下的  caoxinyu 模块之间通迅的内部接口。明确的说：  
      module ?src 目录中的源文件不允许直接互相引用，而只允许通过  
      include 目录访问其它模块的内部接口? 
      当然，不建议把所有的头文件都放在 include 目录中，那样就失去了? 
      离的意义。另外，非常不建议在 include 目录文件中出现框架头文件? 
      框架数据类型的依赖? 

7、问：请介绍一?module/framework.cpp 文件的精? 
   答：该文件是GRocket框架的精髓。虽然你看到向导生成了这么多代码，但  
      实际上框架对模块的要求很少：  
      1) 框架的接口是 C 语言的，模块只需要在动态链接库中导出一个C函数  
         函数名是 gr_version，该函数与框架协商版本兼容性，同时向框? 
         提供模块需要使用的6个回调处理函数指针? 
         框架为了避免模块使用全局变量，提供了全局变量的替代品? 
         (1) ?gr_version 里由模块指定全局变量的字节数，由框架分配  
             内存并清空，模块代码使用? 
         (2) 在后续即将介绍的6个函数中，有一个参数是 gr_server 类型  
             指针，通过该指针可以访问给模块使用的全局变量的内? 
         这样，模块里就完全没有必要使用全局变量，避免了很多问题  
         看看 framework_t::instance 函数的实现，是它?C 语言的模块切  
         换成?C++ 语言  
         再后面，我们会介绍框架会调用?个由模块实现的C函数? 
      2) init - 初始化函数。框架会在父进程?Worker 初始化时调用  
         该函数，便于模块在不同的阶段初始化。注意前面我提到?Worker? 
         但没说是 Worker 进程还是 Worker 线程，那是因为在Windows? 
         Worker 是线程，在非Windows可以通过配置文件?[server]tcp.in.worker_type
         配置项是 process 还是 thread 来指?Worker是进程还是线? 
         非Windows下默认Worker是进程，而且非Windows下的 Worker? 
         程是 fork 出来的，也就是说模块可以在父进程初始化时初始化一? 
         内容，这些内容在 Worker 里同样可用? 
         做为框架的模块，必须要了解的是数据收与发都是在Worker里进行的  
      3) term - 卸载函数。框架会在父进程?Worker 退出前调用本函  
         数，有了 gr_init 的介绍，这个函数就很好理解了，它就是gr_init  
         的反过程  
      4) tcp_accept - ?accept 了一?TCP 连接之后，本函数会被  
         调用，本函数有两个意义：  
         (1) 模块可以为每个TCP连接绑定一个对?框架提供对象指针的存?  
         (2) 如果模块决定不伺候该连接，框架立马就会关了这个socket  
      5) tcp_close - ?close 了一?TCP 连接之前，本函数会被  
         调用，模块可以删除为每个TCP连接绑定的对? 
      6) proc_binary - 处理用户协议包。无论是TCP还是UDP都会调用? 
         函数，可以通过参数取得当前是TCP还是UDP。注意：框架针对任何? 
         收到的数据，都会首先判断是不是HTTP包，如果是HTTP包，则调? 
         proc_http 回调，这就是框架可以在一个连接里可以混合处理HTTP  
         和用户包的原因? 
      7) proc_http - 处理HTTP协议包。无论是TCP还是UDP都会调用本函  
         数，可以通过参数取得当前是TCP还是UDP。支持HTTP请求包和应答  
         包。HTTP协议的所有字段都已经被解析，以结构的方式提供给模块处  
         ? 

8、问：请介绍一下框架生成代码中?framework_t ? 
   答：该类是框架生成的代码精髓。它有以下几个使命：  
      1) GRocket 的框架接口为C语言，该类将C语言的回调转换成 C++语言  
         必竟还是C++开发效率高? 
      2) 对外隐藏?GRocket 框架，在头文件中不出现框架特有的头文件和  
         数据类型。这种局部化是程序员的社会化责任的一种表现。如果读? 
         码你会看到，framework_t 中框架特有的内容被放到了 framework.cpp  
         文件中，而这个文件是框架 special 的? 
      3) 如果模块中有“全局变量”的需求，则全局变量应该成为 framework_t  
         的成员变? 
      下面我们来分析一?framework_t 类的详细内容  
      1) ?framework.cpp ?gr_init 函数中，通过调用 framework_t ? 
         ?create_instance 函数来创?framework_t 类的实例。注? 
         framework.cpp ?gr_version 函数中有这么一句话? 
         param->user_global_bytes = (int)sizeof( framework_t );  
         这句话告诉框架，模块要使用的全局内存区的字节数，然后框架分配  
         共享内存，并将内存以0填充，然后将该指针放入gr_server_t结构? 
         user_global 成员变量中。框架会调用?个由模块实现的函数中  
         都可以直接从函数参数取得gr_server_t结构的指针。这就是全局  
         变量在框架的访问方法。为什么全局变量要分配共享内存呢？这? 
         因为在非Windows下的工作进程模式中，不用共享内存分配的“全局  
         局变量”的有效期只在当前工作进程内? 
         现在?framework.cpp ?framework_t::create_instance 函数  
         首先?gr_server_t::user_global的值是否为空指针，如果? 
         空，则认为已经初始化完成，这是一种容错? 
         由于内存已经由框架分配完了，我们所要做的工作只是通过 placement  
         new 调用 framework_t 的构造函数即可。至此成功将C转成了C++  
      2) 别急，以上只是创建?framework_t 对象，还没初始化呢，在调用了  
         framework_t的构造函数后create_instance函数还调用init_framework_inner  
         函数来初始化自己。后者除了保存框架指针gr_server_t以外，还  
         保存了另外两个结构指针：gr_i_server_t ?gr_i_gcom_t? 
         gr_i_server_t 是框架内置的基础函数集，允许模块调用框架的内  
         内置功能，对模块来说，这个结构中的函数是一定会使用到的? 
         gr_i_gcom_t 是框架内置的另一种RPC风格的模块的调用接口。GCOM  
         的全称是Grocket Component Model。由此得知服务器扩展模块? 
         以调用GCOM模块，GCOM是框架提供的另一种编写底层模块的方法，比  
         起服务器扩展模块，基本没有什么规则约束，只要导出C风格的函数就  
         可以挂在框架中被其它服务器扩展模块动态调用? 
         以上工作都做完了，会调用 framework_t::init 函数来完成应用层? 
         初始化，这个函数是空的，留待模块编写者填写? 
      3) 在框架每次创?Worker 时，gr_init 函数会被调用，gr_init? 
         在这种情况下，会调用 init_worker 函数，这个函数中空的，留? 
         模块编写者编写。要注意的是 Worker 可能是线程也可能是进程，? 
         果模块想取得这个配置，只需要调?framework_t::worker_is_process  
      4) ?framework.cpp ?gr_term 函数中，通过调用 framework_t ? 
         ?destroy_framework_inner 实现?framework_t 的删除。由于该类所  
         用内存是由框架分配的，所以我们只需要调?framework_t 的析构函  
         数即可，你会看到这个：this->~framework_t()? 
         在析构函数调用的前面，会调用 framework_t::destroy_server 函数  
         完成服务器模块的反初始化，这个函数是空的，留待模块编写者填写? 

9、问：为什么在生成的代码中，明明可以用函数参数传递的值，却用结构传呢? 
      比如framework_t类的：tcp_accept、tcp_close、proc_binary? 
   答：好问题！主持人发奖品? 
      这实际上是考虑了今后在增删功能后，将代码改动的波及面影响降到最低? 
      好哲学啊！能不能具体一点儿说呢？比?tcp_accept_ctxt_t 是存  
      放tcp_accept的参数，目前只有4个参数，但实际上框架还提供了其它  
      更多信息，我只是挑其中可能比较常用的4项扔了过来，万一以后需要，  
      随时可以向结构尾部增加，而调用方代码基本不受影响，只是使用新参数  
      的调用方代码直接使用即可，但想想如果把结构改成参数传的情况吧... 
      实际上你会看到，框架本身也使用了这个技巧来规避一些函数万一升级  
      带来的影响面，做到完全兼容老版本? 

10、问：GRocket框架的原码规范与生成的代码规范不一样，为什么？  
       甚至GRocket是用C写的，工具生成的代码却是C++的，很奇怪? 
    答：GRocket程序的代码规范是使用我个人喜欢的，但我知道更多人使用的代  
       码风格不是这样的，于是在向导生成的代码中使用了大多数人喜欢的? 
       码风格? 
       至于语言的差别：GRocket在最初的一个基本目标就是性能超越 nginx
       为了能简单的在性能上超越它，我不能随随便便付出C++的成本，性能  
       最本质的原因。但在框架上面写应用考虑的就不一样了，我一直以来的  
       思想是“在框架层把性能做尽”，但对应用层不能苛求性能，因为业务的  
       灵魂是快速开发上线、降低维护成本? 

9、问：请介绍一下conf目录下的配置文件  caoxinyu_svr.ini  
   答：  

